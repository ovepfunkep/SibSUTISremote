<!DOCTYPE html>
<html lang="en">

<head>

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="do.sibsutis.ru">

  <title>Лекция 11. Конспект лекций</title>
	
	<link rel="icon" type="image/png" href="../lib/css/favicon.png">
  <!-- Bootstrap Core CSS -->
  <link href="../lib/css/bootstrap.css" rel="stylesheet">
  <link href="../lib/css/prettify.css" rel="stylesheet">	
  <!-- Custom CSS -->
  <link href="../lib/css/scrolling-nav.css" rel="stylesheet">

  <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
  <![endif]-->
</head>

<!-- The #page-top ID is part of the scrolling feature - the data-spy and data-target are part of the built-in Bootstrap scrollspy function -->

<body id="page-top" data-spy="scroll" data-target=".navbar-fixed-top">
  <!-- Navigation -->
<nav class="navbar navbar-default navbar-fixed-top">
 <div class="container">
  <!-- Brand and toggle get grouped for better mobile display -->
  <div class="navbar-header">
   <li class="hidden"> <a class="page-scroll" href="#page-top"></a> </li>
	 
	 <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
   </button>
	 
   <a class="navbar-brand " href="../index.htm"> 
  <text class = "hidden-xs">Программирование (часть 2)</text> 
  <text class = "visible-xs">Программирование (часть 2)</text>
	 </a>
  </div>

  <!-- Collect the nav links, forms, and glyphicon glyphicon-list-alt content for toggling -->
  <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
   
	 <!-- <ul class="nav navbar-nav">
		<li><a href="#"></a></li> 
   </ul> -->
	
   <ul class="nav navbar-nav navbar-right">
    <li class="dropdown">
		<button type="button" class="navbar-toggle dropdown-toggle hidden-xs" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
		</button>	   
		<a class = "dropdown-toggle visible-xs" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Материалы</a>
     <ul class="dropdown-menu">
    <li><a href="../index.htm">Аннотация курса</a></li>
      <li role="separator" class="divider"></li>
  
 <li><a href="lec_index.htm">Теория</a></li>
 
<li><a href="labs.htm">Лабораторные работы</a></li>  
 <li><a href="c_work.htm">Контрольная работа</a></li>

 
      <li role="separator" class="divider"></li>
   

      <li><a href="lit.htm">Литература</a></li>
      <!--li><a href="q.htm">Вопросы для самопроверки</a></li-->			
     </ul>
 </li>
 </ul>
  </div><!-- /.navbar-collapse -->
 </div><!-- /.container-fluid -->
</nav>


  <div id="intro" class="section content-section ">
    <div class="container">
       <div class="row">
        <div class="col-lg-12">	


<!-- содержание -->	
<div class="page-header">				
<h3><a href="#">11. Указатели</a></h3>
<a href="#1" class=punkt>11.1. Адреса и указатели</a><br>
<a href="#2" class=punkt>11.2. Операции над указателями</a><br>
<a href="#3" class=punkt>11.3. Способы доступа к элементам массива</a><br>
<a href="#4" class=punkt>Контрольные вопросы</a><br>

</div>
<!--начало-->
<a name=1 class="anchor"></a>
<h3>11.1. Адреса и указатели</h3>
<P>В языке Си указатели введены как объекты, значениями которых служат адреса
 других объектов либо функций. Каждая переменная в программе – это объект,
 имеющий имя и значение. По имени можно обратиться к переменной и получить
 её значение. В операторе присваивания выполняется обратное действие –
 имени переменной ставится в соответствие значение выражения. С точки зрения
 машинной реализации имя переменной соответствует адресу того участка памяти,
 который для неё выделен, а значение переменной – содержимому этого участка
 памяти. Чтобы получить адрес в явном виде, в языке Си применяют унарную
 операцию &amp;. Выражение &amp;a позволяет получить адрес участка памяти,
 выделенного для переменной a. </p>
<P>&#9;Имея возможность с помощью операции &amp; (взятие
 адреса) определять адрес переменной или другого объекта программы, нужно
 уметь его сохранять, преобразовывать и передавать. Для этих целей в языке
 Си введены переменные типа “указатель”, которые обычно называют просто
 указателями. Значением указателя служит или адрес объекта конкретного
 типа, или нулевой адрес, для обозначения которого определена специальная
 константа NULL (в файле stdio.h). </P>
<P>&#9;Как и всякие переменные, указатели нужно определять
 и описывать, для чего используется символ ‘*’. В описании и определении
 указателей необходимо сообщать, на объект какого типа ссылается этот указатель:</P>
<P class=punkt>char *z; // z- указатель на объект символьного типа</P>
<P class=punkt>int *k,*i; // k,i – указатели на объекты целого типа</P>
<P class=punkt>float *f; // f – указатель на объект вещественного типа</P>
<P>Обозначения *z, *i, *f имеют права переменных соответствующих
 типов. Оператор *z=’ ‘; засылает символ “пробел” в тот участок памяти,
 адрес которого определяет указатель z. Оператор *k=*i=0; заносит целые
 нулевые значения в те участки памяти, адреса которых заданы указателями
 k,i. Указатель может ссылаться на объекты того типа, который присутствует
 в определении указателя. Указатели, в определении которых использован
 тип void, могут ссылаться на объекты любого типа, однако к ним нельзя
 применять операцию разыменования ‘*’. </P>
<P>&nbsp;</P>
<a name=2 class="anchor"></a>
<h3>11.2. Операции над указателями</h3>
<P>&#9;В языке Си допустимы следующие операции над указателями:
 присваивание, разыменование (получение значения того объекта, на который
 ссылается указатель), получение адреса самого указателя, унарные операции
 изменения значения указателя ++ и - - , аддитивные операции + - и операции
 сравнений.</P>
<P></P>
<P><b> Операция присваивания</b></P>
<P>&#9;Операция присваивания предполагает, что слева от
 знака присваивания помещено имя указателя, справа – указатель, уже имеющий
 значение, либо адрес объекта того же типа, что и указатель, либо константа
 NULL. Например, i=&amp;d; k=i; z=NULL; Иногда требуется присвоить указателю
 одного типа значение указателя другого типа. В этом случае используется
 “приведение типов”, например: </P>
<P class=punkt>&#9;char *z; // z - указатель на символ</P>
<P class=punkt>&#9;int *k; // k – указатель на целое</P>
<P class=punkt>&#9;z=(char *) k // приведение типов</P>
<P>&#9;Подобно любым переменным, переменная типа указатель
 имеет имя, собственный адрес в памяти и значение. Значение можно использовать,
 например, присваивать другому указателю или печатать. Адрес указателя
 может быть также получен с помощью операции взятия адреса &amp;, т. е.
 &amp;&lt;имя указателя&gt; определяет, где в памяти размещён указатель.
 Содержимое этого участка памяти является значением указателя.</P>
<P></P>
<P><b>Унарные операции ++ и - -</b></P>
<P>&#9;С помощью операций ++ и - - числовые значения указателей
 меняются по-разному в зависимости от типа данных, на которые ссылается
 указатель. Если указатель связан с типом char, то при выполнении операций
 ++ и - - его числовое значение изменяется на 1 (указатель z в рассмотренных
 примерах). Если указатель связан с типом int (указатель k), то операции
 ++ и - - изменяют его числовое значение на 2 (тип int имеет размер 2 байта).
 Указатель, связанный с типом float или long операциями ++ ,- - изменяется
 на 4 . Таким образом, при изменении указателя на единицу указатель переходит
 к началу следующего (или предыдущего) поля той длины, которая определяется
 типом. </P>
<P></P>
<P><b> Аддитивные операции</b></P>
<P>&#9;Аддитивные операции по-разному применимы к указателям.
 Две переменные типа указатель нельзя суммировать, однако к указателю можно
 прибавить целую величину. При этом вычисляемое значение зависит от типа
 объекта, с которым связан указатель. Например, если указатель относится
 к объекту типа long, то прибавление к нему единицы увеличивает реальное
 значение на 4, т.е. осуществляется переход к адресу следующего в памяти
 объекта типа long. В отличие от операции сложения операция вычитания применима
 не только к указателю и целой величине, но и к двум указателям на объекты
 одного типа. При этом разность вычисляется в единицах, кратных длине отдельного
 элемента того типа, к которому отнесён указатель:</P>
<P class=punkt>&#9;int x[5], *i, *k, j;</P>
<P class=punkt>&#9;i=&amp;x[0]; k=&amp;x[4]; j=k-i;</P>
<P>j принимает значение 4, а не 8, как можно было бы предположить,
 исходя из того, что каждый элемент массива x [] занимает 2 байта.</P>
<P>&#9;Добавление целочисленного значения n к указателю,
 адресующему некоторый элемент массива, приводит к тому, что указатель
 получает значение адреса того элемента, который отстоит от текущего на
 n элементов. Если длина элемента массива равна d байтов, то численное
 значение указателя изменяется на (d*n). Рассмотрим пример, иллюстрирующий
 перечисленные правила:</P>
<pre class="prettyprint">
 int x[4]={0,2,4,6};
 
 int *i, y; 

 i=&amp;x[0]; // i равно адресу элемента x[0] 

 y=*i; // y равно 0; i равно &amp;x[0]
 
 y=*i++; // y равно 0; i равно &amp;x[1] 

 y=++*i; // y равно 3; i равно &amp;x[1] 

 y=*++i; // y равно 4; i равно &amp;x[2] 

 y=(*i)++ // y равно 4; i равно &amp;x[2]
 
 y=++(*i) // y равно 6; i равно &amp;x[2] 
</Pre>
<P><b> Операции отношения</b></P>
<P>&#9;К указателям применяются операции сравнения ‘&gt;’,
 ’&gt;=’, ’&lt;’, ’&lt;=’, ’==’, ’!=’. Но сравнивать указатели можно только
 с другими указателями того же типа или с константой NULL, обозначающей
 значение условного нулевого адреса. </P>
<P>&#9;Приведём пример, в котором используются операции
 над указателями и выводятся полученные значения. Для вывода значений указателя
 в форматной строке функции printf() используется спецификация преобразования
 %p.</P>
<pre class="prettyprint">
#include &lt;stdio.h&gt;

#include &lt;conio.h&gt;

float x[]={10.0, 20.0, 30.0, 40.0, 50.0}

void main()

{ float *u1, *u2;

 int i;

 clrscr();

 printf("\n Адреса указателей: &u1=%p &u2=%p",&u1, &u2);

 printf("\n Адреса элементов массива: \n");

 for (i=0; i&lt;5; i++)

    printf(" &x[%d] =%p", i, &x[i]);

 printf("\n Значения элементов массива: \n");

 for (i=0; i&lt;5; i++)

    printf( "x[%d]=%5.1f ", i, x[i]);

 printf(" \n Доступ к элементам массива с помощью указателей: \n");

 for (u1=&x[0], u2=&x[4]; u1<=u2; u1++)

    printf("u1=%p, *u1=%5.1f \n",u1,*u1);

 for (u1=&x[0], u2=&x[4]; u2>=u1; u2--)

    printf("u2=%p, *u2=%5.1f \n",u2,*u2);

getch();

}
</Pre>
<P>&nbsp;</p>
<a name=3 class="anchor"></a>
<h3>11.3. Способы доступа к элементам
 массива</h3>
<P><B>&#9;</b>В соответствии с синтаксисом языка Си имя
 массива без индексов является указателем – константой, т. е. адресом его
 первого элемента (с нулевым индексом). </P>
<P>&#9;Рассмотрим задачу инвертирования массива символов
 и различные способы её решения с применением указателей. </P>
<P></P>
<P><b>Способ 1.</b></P>
<pre class="prettyprint">
char z[80], s;

char *d, *h; // d и h – указатели на символьные объекты

for (d=z, h=&z[79]; d&lt;h; d++, h--)

{ s=*d; *d=*h; *h=s; }
</Pre>
<P>&#9;В заголовке цикла указателю d присваивается адрес
 первого ( с нулевым индексом) элемента массива z. Здесь можно было бы
 применить и другую операцию, а именно d=&amp;z[0]. Указатель h получает
 значение адреса последнего элемента массива z. Цикл выполняется до тех
 пор, пока z&lt;h. После каждой итерации значение d увеличивается, значение
 h уменьшается на 1. При первой итерации в теле цикла выполняется обмен
 значений z[0] и z[79], так как d – адрес z[0], h – адрес z[79]. При второй
 итерации значением d является адрес z[1], для h – адрес z[78] и т. д.</P>
<P><b>Способ 2.</b></P>
<pre class="prettyprint">
char z[80], s *d, *h;

for (d=z, h=&z[79]; d&lt;h)

{ s=*d; *d++ = *h; *h-- =s;}
</Pre>
<P>&#9;Приращение указателя d и уменьшение указателя h перенесены
 в тело цикла. В выражениях *d++ и *h—операции увеличения и уменьшения
 на 1 имеют тот же приоритет, что и унарная операция *. Поэтому изменяются
 на 1 не значения элементов массива, на которые указывают d и h, а сами
 указатели. Последовательность действий такая: по значению указателя d
 или h обеспечивается доступ к элементу массива; в этот элемент заносится
 значение из правой части оператора присваивания; затем увеличивается (уменьшается)
 на 1 значение указателя d (или h).</P>
<P><b>Способ 3.</b></P>
<pre class="prettyprint">
char z[80], s, *d, *h;

d=z;

h=&z[79];

while (d&lt;h)

{ s=*d; *d++ =*h; h*-- = s;}
</Pre>
<P><b>Способ 4.</b></P>
<pre class="prettyprint">
char z[80], s;

int i;

for (i=0; i&lt;40; i++)

{ s=*(z+i); *(z+i)=*(z+(79-i)); *(z+(79-i))=s; }
</Pre>

<P>&#9;Данный пример иллюстрирует возможность использования
 вместо индексированного элемента z[i] выражения *(z+i), т. к. имя массива
 без индексов есть адрес его первого элемента. Прибавив к имени массива
 целую величину, получаем адрес соответствующего элемента, т. о. &amp;z[i]
 и z+i - это две формы определения адреса одного и того же элемента массива.
 </P>
<P>&#9;Итак, операция индексирования z[n] определена таким
 образом, что она эквивалентна *(z+n), где z – имя массива, n – целое.
 Для многомерного массива правила остаются теми же. Таким образом, z[n][m]
 эквивалентно *(*(z+n)+m).</P>
<P>&#9;Отметим, что имя массива не является переменной типа
 указатель, а есть константа – адрес начала массива. Таким образом, к имени
 массива не применимы операции ++ и -- , имени массива нельзя присвоить
 значение, т. е. имя массива не может использоваться в левой части оператора
 присваивания. </P>
<P>&#9;Изменение указателя на 1 приводит к разным результатам
 в зависимости от типа объекта, с которым связан указатель. Значение указателя
 изменяется на длину участка памяти, выделенного под этот объект, поэтому
 для символьного массива переход к соседнему элементу изменяет указатель
 на 1, для целочисленного – на 2, для вещественного – на 4. <br>
 </P>
<P>&nbsp;</P>
<a name=4 class="anchor"></a>
<h3>11.4. Контрольные вопросы</h3>
<P></P>
<P>1. Понятие и определение указателя.</P>
<P>2. Какие операции допустимы над указателями?</P>
<P>3. Что можно присвоить переменной типа указатель?</P>
<P>4. Как можно использовать унарные и аддитивные операции
 для указателей?</P>
<P>5. Особенности применения к указателям операций
 сравнения.</P>
<P>6. Способы доступа к элементам массива с помощью
 указателей. </P>
<br><br>
<!--конец-->
      
				


				</div>
			</div>
			
      </div>
    </div>
  </div>
	
	<!--Меню навигации по Темам -->	
	<div aria-label="..." class = "nav-menu">
	 <ul class="pager background-transition-slow">
		 <li title="Наверх" style = "margin-right:15px;	"><a class = "glyphicon glyphicon-menu-up page-scroll" href="#page-top"></a></li>
		 <li title="К предыдущей лекции"><a class = "glyphicon glyphicon-menu-left page-scroll" href="lec10.htm"></a></li>
		 <li title="В содержание"><a class = "glyphicon glyphicon-list-alt" href="lec_index.htm"></a></li>
		 <li title="К следующей лекции"><a class = "glyphicon glyphicon-menu-right page-scroll" href="lec12.htm"></a></li>
	 </ul>
	</div>
	<!---->
	
	</div>
  <!-- jQuery -->
  <script src="../lib/js/jquery.js"></script>
<script src="../lib/css/prettify.js"></script>
<script type="text/javascript">
  !function ($) {
$(function(){
window.prettyPrint && prettyPrint()  
    })
  }(window.jQuery)
</script>

  <!-- Bootstrap Core JavaScript -->
  <script src="../lib/js/bootstrap.min.js"></script>

  <!-- Scrolling Nav JavaScript -->
  <script src="../lib/js/jquery.easing.min.js"></script>
  <script src="../lib/js/scrolling-nav.js"></script>

</body>

</html>
